class RoleLink < ActiveRecord::Base
  belongs_to :ancestor, :class_name => 'Role'
  belongs_to :descendent, :class_name => 'Role'
  
  named_scope :direct, :conditions => {:direct => true}
  
  named_scope :descendent_roles, :include => :descendent
  named_scope :ancestor_roles, :include => :ancestor
  
  named_scope :with_ancestor, lambda { |ancestor| {:conditions => {:ancestor_id => ancestor}}}
  named_scope :with_descendent, lambda { |ancestor| {:conditions => {:descendent_id => ancestor}}}
  
  
  validates_uniqueness_of :descendent_id, :scope => [:ancestor_id,:type]
  validates_presence_of :ancestor_id,:descendent_id, :type, :count
  validates_numericality_of :ancestor_id,:ancestor_id, :count
  
  def self.between(parent,child)
    return self.class.find_by_ancestor_id_and_descendent_id(parent,child)
  end
    
  #Make sure we do not have a self redirecting edge
  def before_validation
    self[:direct] = false if self[:direct].nil?
  end
  
  def validate
    if self[:ancestor_id] == self[:descendent_id]
      errors.add_to_base('The parent role must be different from the child role.')  
    end
    unless self.class.find_by_ancestor_id_and_descendent_id(self[:descendent_id],self[:ancestor_id]).nil?
      errors.add_to_base('The opposite link between roles already exists.') 
    end
  end
  
  def after_initialize
    self[:count] = 0 if self[:count].nil?
    self[:direct] = false if self[:direct].nil?  
  end
  
  def self.add(parent,child)
    link = self.find_by_ancestor_id_and_descendent_id(parent,child)
    link = self.new(:ancestor_id => parent.id, :descendent_id => child.id) if link.nil?
    link.direct = true
    return link
  end
  
  def self.remove(parent,child)
    link = self.find_by_ancestor_id_and_descendent_id(parent,child)
    raise 'Link does not exist' if link.nil?
    link.direct = false
    return link
  end
  
  def direct=(val)
    unless val == self[:direct]
      self[:direct] = val
      if val == true
        self.count += 1
        self.effectuate(:add)
        self.save!
      else
        self.count -= 1
        self.effectuate(:remove)
        if self.count == 0
          self.destroy
        else
          self.save!
        end
      end
    end
  end
  
  def effectuate(kind)
    upchain = self.class.find_all_by_descendent_id(self[:ancestor_id])
    upnodes = [self[:ancestor_id]]
    upchain.each do |link|
      upnodes << link.ancestor_id
    end
    downchain = self.class.find_all_by_ancestor_id(self[:descendent_id])
    downnodes = [self[:descendent_id]]
    downchain.each do |link|
      downnodes << link.descendent_id
    end
    #all things using this link
    upnodes.each do |upnode|
      if upnode == self[:ancestor_id]
        toplink = nil
        topcount = 1
      else
        toplink = self.class.find_by_ancestor_id_and_descendent_id(upnode,self[:ancestor_id])
        topcount = toplink.count
      end
      downnodes.each do |downnode|
        if downnode == self[:descendent_id]
          bottomlink = nil
          bottomcount = 1
        else
          bottomlink = self.class.find_by_ancestor_id_and_descendent_id(self[:descendent_id],downnode)
          bottomcount = bottomlink.count
        end
        unless toplink.nil? && bottomlink.nil?
          link = self.class.find_by_ancestor_id_and_descendent_id(upnode,downnode)
          if kind == :add
            if link.nil?
              link = self.class.new(:ancestor_id => upnode,:descendent_id => downnode)
            end
            link.count = 0 if link.count.nil?
            link.count += bottomcount * topcount
            link.save!
          elsif kind == :remove
            if link.nil?
              raise 'Graph is broken somehow'
            else
              link.count = 0 if link.count.nil?
              link.count -= bottomcount * topcount
              if link.count == 0
                link.destroy
              else
                link.save!
              end
            end
          end
        end  
      end
    end
  end
end